<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #222222; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls, model, skeletonHelper; // Cena
    let hemiLight, dirLight; // Iluminação
    let mixer, clock; // Animação

    function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        window.addEventListener('resize', onWindowResize);
        animate();
    }

    // --- INTERFACE COM FLUTTER ---

    window.loadModel = function(base64Data) {
        if (model) scene.remove(model);
        if (skeletonHelper) scene.remove(skeletonHelper);
        if (mixer) mixer.stopAllAction();

        const loader = new GLTFLoader();
        const binaryData = atob(base64Data);
        const arrayBuffer = new ArrayBuffer(binaryData.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < binaryData.length; i++) uint8Array[i] = binaryData.charCodeAt(i);

        const blob = new Blob([uint8Array], { type: 'model/gltf-binary' });
        const url = URL.createObjectURL(blob);

        loader.load(url, (gltf) => {
            model = gltf.scene;
            scene.add(model);

            // Setup de animações
            mixer = new THREE.AnimationMixer(model);
            window.modelAnimations = gltf.animations;

            skeletonHelper = new THREE.SkeletonHelper(model);
            skeletonHelper.visible = false;
            scene.add(skeletonHelper);

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3()).length();

            controls.target.copy(center);
            camera.position.set(center.x, center.y + size, center.z + size * 4.2);
            controls.update();
            URL.revokeObjectURL(url);
        });
    };

    window.getAnimationList = function() {
        if (!window.modelAnimations || window.modelAnimations.length === 0) return JSON.stringify([]);
        return JSON.stringify(window.modelAnimations.map(a => a.name));
    };

    window.playAnimation = function(name) {
        if (!mixer || !window.modelAnimations) return;
        const clip = THREE.AnimationClip.findByName(window.modelAnimations, name);
        if (clip) {
            mixer.stopAllAction();
            mixer.clipAction(clip).play();
        }
    };

    window.updateLightPosition = function(x, y, z) { dirLight.position.set(x, y, z); };
    window.updateLightIntensity = function(i) { dirLight.intensity = i; };
    window.updateLightColor = function(c) { dirLight.color.set(c); };

    window.toggleRig = function(show) {
        if (skeletonHelper) {
            skeletonHelper.visible = show;
            model.traverse((child) => { if (child.isMesh) child.visible = !show; });
        }
    };

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        if (mixer) mixer.update(delta);
        controls.update();
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>