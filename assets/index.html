<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; background-color: #222222; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

    let scene, camera, renderer, controls, model, skeletonHelper;
    let hemiLight, dirLight;
    let mixer, clock, currentAction;

    function init() {
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.5);
        scene.add(hemiLight);

        dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        window.addEventListener('resize', onWindowResize);
        animate();
    }

    window.loadModel = function(base64Data) {
        if (model) scene.remove(model);
        if (skeletonHelper) scene.remove(skeletonHelper);
        if (mixer) mixer.stopAllAction();

        const loader = new GLTFLoader();
        const binaryData = atob(base64Data);
        const arrayBuffer = new ArrayBuffer(binaryData.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < binaryData.length; i++) uint8Array[i] = binaryData.charCodeAt(i);

        const blob = new Blob([uint8Array], { type: 'model/gltf-binary' });
        const url = URL.createObjectURL(blob);

        loader.load(url, (gltf) => {
            model = gltf.scene;
            scene.add(model);
            mixer = new THREE.AnimationMixer(model);
            window.modelAnimations = gltf.animations;
            skeletonHelper = new THREE.SkeletonHelper(model);
            skeletonHelper.visible = false;
            scene.add(skeletonHelper);

            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3()).length();
            controls.target.copy(center);
            camera.position.set(center.x, center.y + size, center.z + size * 4.2);
            controls.update();
            URL.revokeObjectURL(url);
        });
    };

    window.addNewAnimationFromPose = function(animationName, poseDataJson) {
        if (!model) return JSON.stringify([]);
        const poseData = JSON.parse(poseDataJson);
        const tracks = [];
        const allBones = [];
        model.traverse(b => { if(b.isBone) allBones.push(b); });
        allBones.forEach(bone => {
            const times = poseData.map(p => p.time);
            const values = [];
            poseData.forEach(p => {
                if (p.rotations[bone.name]) {
                    const q = p.rotations[bone.name];
                    values.push(q[0], q[1], q[2], q[3]);
                } else {
                    values.push(bone.quaternion.x, bone.quaternion.y, bone.quaternion.z, bone.quaternion.w);
                }
            });
            const track = new THREE.QuaternionKeyframeTrack(`${bone.name}.quaternion`, times, values);
            track.setInterpolation(THREE.InterpolateLinear);
            tracks.push(track);
        });

        const clip = new THREE.AnimationClip(animationName, -1, tracks);
        if (!window.modelAnimations) window.modelAnimations = [];
        window.modelAnimations.push(clip);
        return JSON.stringify(window.modelAnimations.map(a => a.name));
    };

    window.removeAnimation = function(name) {
        if (!window.modelAnimations) return JSON.stringify([]);
        window.modelAnimations = window.modelAnimations.filter(a => a.name !== name);
        if (currentAction && currentAction.getClip().name === name) {
            mixer.stopAllAction();
            currentAction = null;
        }
        return JSON.stringify(window.modelAnimations.map(a => a.name));
    };

    window.exportGLB = function() {
        if (!model) return;
        const exporter = new GLTFExporter();
        const options = { binary: true, animations: window.modelAnimations };
        exporter.parse(model, function (result) {
            const blob = new Blob([result], { type: 'application/octet-stream' });
            const reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = function() {
                const base64data = reader.result.split(',')[1];
                if (window.FileHandler) window.FileHandler.postMessage(base64data);
            }
        }, (err) => console.error(err), options);
    };

    window.getModelStats = function() {
        if (!model) return JSON.stringify({ vertices: 0, faces: 0 });
        let vertices = 0, faces = 0;
        model.traverse((child) => {
            if (child.isMesh) {
                const geo = child.geometry;
                if (geo.attributes.position) vertices += geo.attributes.position.count;
                if (geo.index) faces += geo.index.count / 3;
                else if (geo.attributes.position) faces += geo.attributes.position.count / 3;
            }
        });
        return JSON.stringify({ vertices: Math.round(vertices), faces: Math.round(faces) });
    };

    window.getBoneList = function() {
        if (!model) return JSON.stringify([]);
        const bones = [];
        model.traverse((child) => {
            if (child.isBone) {
                bones.push({
                    name: child.name,
                    uuid: child.uuid.substring(0, 8),
                    parent: (child.parent && child.parent.isBone) ? child.parent.name : null
                });
            }
        });
        return JSON.stringify(bones);
    };

    window.getAnimationList = function() {
        if (!window.modelAnimations) return JSON.stringify([]);
        return JSON.stringify(window.modelAnimations.map(a => a.name));
    };

    window.getTPoseReferences = function() {
        if (!model) return "{}";

        const references = {};
        const bonePositions = {};

        model.traverse((bone) => {
            if (bone.isBone) {
                const worldPos = new THREE.Vector3();
                bone.getWorldPosition(worldPos);
                bonePositions[bone.name] = worldPos;
            }
        });

        model.traverse((bone) => {
            if (bone.isBone && bone.children.length > 0) {
                const child = bone.children.find(c => c.isBone);
                if (child) {
                    const startPos = bonePositions[bone.name];
                    const endPos = bonePositions[child.name];

                    if (startPos && endPos) {
                        const dir = new THREE.Vector3()
                            .subVectors(endPos, startPos)
                            .normalize();

                        references[bone.name] = {
                            x: dir.x,
                            y: dir.y,
                            z: dir.z,
                            posX: startPos.x,
                            posY: startPos.y,
                            posZ: startPos.z,
                            childPosX: endPos.x,
                            childPosY: endPos.y,
                            childPosZ: endPos.z
                        };
                    }
                }
            }
        });

        const bbox = new THREE.Box3().setFromObject(model);
        const size = bbox.getSize(new THREE.Vector3());

        references['_metadata'] = {
            modelHeight: size.y,
            modelWidth: size.x,
            modelDepth: size.z
        };

        return JSON.stringify(references);
    };

    window.playAnimation = function(name) {
        if (!mixer || !window.modelAnimations) return;
        const clip = THREE.AnimationClip.findByName(window.modelAnimations, name);
        if (clip) {
            mixer.stopAllAction();
            currentAction = mixer.clipAction(clip);
            currentAction.play();
            currentAction.paused = false;
        }
    };

    window.pauseAnimation = () => { if (currentAction) currentAction.paused = true; };
    window.resumeAnimation = () => { if (currentAction) currentAction.paused = false; };
    window.resetAnimation = () => { if (currentAction) { currentAction.reset(); currentAction.play(); } };
    window.setAnimationSpeed = (s) => { if (currentAction) currentAction.timeScale = s; };
    window.updateLightPosition = (x, y, z) => { dirLight.position.set(x, y, z); };
    window.updateLightIntensity = (i) => { dirLight.intensity = i; };
    window.updateLightColor = (c) => { dirLight.color.set(c); };
    window.toggleRig = (show) => {
        if (skeletonHelper) {
            skeletonHelper.visible = show;
            model.traverse((c) => { if (c.isMesh) c.visible = !show; });
        }
    };

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (mixer) mixer.update(clock.getDelta());
        controls.update();
        renderer.render(scene, camera);
    }
    init();
</script>
</body>
</html>